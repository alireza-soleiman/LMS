{% extends "base.html" %}
{% load static %}

{% block title %}SRF Ranking â€” {{ project.title }}{% endblock %}

{% block content %}
<div class="container py-4">
  <h2 class="mb-3">WS3 â€” SRF Method (Playing Cards)</h2>
  <p class="text-muted">
    Drag and drop your <strong>15 selected indicators</strong> to rank them from least to most important.
    You can insert <em>white cards</em> to indicate stronger gaps in importance.
  </p>

  <!-- Progress bar -->
  <div class="progress mb-4" style="height: 8px;">
    <div id="progressBar" class="progress-bar bg-primary" style="width: 0%;"></div>
  </div>

  <!-- Ranking area -->
  <div id="rankingArea" class="d-flex flex-column gap-2 mb-3">
    {% for ind in indicators %}
      <div class="card p-2 d-flex flex-row align-items-center justify-content-between"
           draggable="true" data-id="{{ ind.id }}" style="cursor: move;">
        <div>
          <strong>{{ forloop.counter }}. {{ ind.name }}</strong><br>
          <small class="text-muted">{{ ind.criterion }}</small>
        </div>
        <div>
          <label class="me-1">White cards after:</label>
          <input type="number" min="0" max="10" value="{{ ind.white_cards_after|default:0 }}"
                 class="form-control form-control-sm white-input" style="width:70px; display:inline-block;">
        </div>
      </div>
    {% endfor %}
  </div>

  <div class="d-flex justify-content-between mt-3">
    <button id="saveBtn" class="btn btn-success">ðŸ’¾ Save Ranking</button>
    <a href="{% url 'download_indicators_csv' project.id %}" class="btn btn-outline-secondary">â¬‡ Download CSV</a>
  </div>

  <hr>
  <h5>Computed Weights</h5>
  <table class="table table-sm table-striped" id="weightsTable" style="display:none;">
    <thead class="table-dark">
      <tr><th>#</th><th>Indicator</th><th>White Cards</th><th>Weight</th></tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const rankingArea = document.getElementById("rankingArea");
  const saveBtn = document.getElementById("saveBtn");
  const weightsTable = document.getElementById("weightsTable");
  const weightsBody = weightsTable.querySelector("tbody");
  const progressBar = document.getElementById("progressBar");

  let dragSrcEl = null;

  // ðŸ–± Drag & Drop sorting
  rankingArea.addEventListener("dragstart", (e) => {
    dragSrcEl = e.target;
    e.dataTransfer.effectAllowed = "move";
    e.target.classList.add("opacity-50");
  });

  rankingArea.addEventListener("dragover", (e) => e.preventDefault());

  rankingArea.addEventListener("drop", (e) => {
    e.preventDefault();
    const target = e.target.closest(".card");
    if (dragSrcEl && target && dragSrcEl !== target) {
      const cards = Array.from(rankingArea.children);
      const srcIndex = cards.indexOf(dragSrcEl);
      const targetIndex = cards.indexOf(target);
      if (srcIndex > targetIndex) rankingArea.insertBefore(dragSrcEl, target);
      else rankingArea.insertBefore(dragSrcEl, target.nextSibling);
      dragSrcEl.classList.remove("opacity-50");
      updateProgress();
    }
  });

  rankingArea.addEventListener("dragend", (e) => e.target.classList.remove("opacity-50"));

  // âš™ï¸ Collect data + calculate weights
  function getRankingData() {
    const cards = rankingArea.querySelectorAll(".card");
    let order = [];
    let white_cards = {};
    cards.forEach((card, i) => {
      const id = card.dataset.id;
      const wc = parseInt(card.querySelector(".white-input").value) || 0;
      order.push(parseInt(id));
      white_cards[id] = wc;
    });
    return { order, white_cards };
  }

  function updateProgress() {
    const count = rankingArea.children.length;
    const pct = (count / 15) * 100;
    progressBar.style.width = pct + "%";
  }

  // ðŸ§® Compute weights (client-side preview)
  function computeWeights(order, white_cards) {
    let scores = {};
    let current = 1;
    order.forEach((id) => {
      const wc = white_cards[id] || 0;
      scores[id] = current;
      current += 1 + wc;
    });
    const total = Object.values(scores).reduce((a, b) => a + b, 0);
    const weights = {};
    for (const [id, val] of Object.entries(scores)) {
      weights[id] = (val / total).toFixed(4);
    }
    return weights;
  }

  // ðŸ’¾ Save to backend
  saveBtn.addEventListener("click", () => {
    const { order, white_cards } = getRankingData();
    const weights = computeWeights(order, white_cards);

    fetch("{% url 'indicator_ranking_view' project.id %}", {
      method: "POST",
      headers: {
        "X-CSRFToken": "{{ csrf_token }}",
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ order, white_cards }),
    })
    .then(res => res.json())
    .then(data => {
      if (data.status === "success") {
        alert("âœ… Ranking saved successfully!");
        renderWeights(weights, order, white_cards);
      } else {
        alert("âŒ Error: " + (data.message || "Unknown"));
      }
    })
    .catch(() => alert("âŒ Network error"));
  });

  // ðŸ§¾ Display computed weights
  function renderWeights(weights, order, white_cards) {
    weightsBody.innerHTML = "";
    order.forEach((id, i) => {
      const name = rankingArea.querySelector(`[data-id="${id}"] strong`).innerText;
      const wc = white_cards[id];
      const w = weights[id];
      const row = `<tr><td>${i+1}</td><td>${name}</td><td>${wc}</td><td>${w}</td></tr>`;
      weightsBody.insertAdjacentHTML("beforeend", row);
    });
    weightsTable.style.display = "table";
  }

  updateProgress();
});
</script>
{% endblock %}
