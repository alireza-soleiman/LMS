{% extends "base.html" %}
{% load static %}
{% block title %}SRF Playing Cards â€” {{ project.title }}{% endblock %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-3">
  <div>
    <h1 class="display-5 fw-bold mb-1">Workshop 3 â€” Indicator Ranking (SRF Method)</h1>
    <p class="fs-5 text-muted mb-0">
      Rank and group indicators like playing cards ğŸ´.
      Drag to reorder â†’ use â€œâ¬œ White Cardâ€ for gaps â†’ merge equals with â€œğŸ”—â€.
    </p>
  </div>
  <a href="{% url 'workshop_list' project.id %}" class="btn btn-outline-secondary px-3">
    â† Back to Workshops
  </a>
</div>
<hr class="my-4">

<div class="alert alert-info">
  <h5>ğŸ§© How the SRF (Simos) Method Works</h5>
  <p>
    Drag the cards to rank indicators by importance. Use â€œâ¬œ White Cardsâ€ to indicate importance gaps
    and â€œğŸ”— Merge Selectedâ€ for equal-importance indicators.
  </p>
  <p>
    Click â€œğŸ’¾ Save SRF Weightsâ€ to compute and save weights automatically.
    This method converts qualitative rankings into quantitative weights using the Revised Simos procedure.
  </p>
</div>

<!-- ğŸ¯ Buttons -->
<div class="text-center mb-3">
  <button id="addWhiteCard" class="btn btn-outline-secondary btn-sm">â¬œ Add White Card (Gap)</button>
  <button id="mergeCards" class="btn btn-outline-primary btn-sm">ğŸ”— Merge Selected (Equal Importance)</button>
  <a href="{% url 'workshop_list' project.id %}" class="btn btn-outline-secondary px-3">
    â† Back to Workshops
  </a>
</div>
<div class="text-center mb-2">
  <span class="badge bg-danger-subtle text-danger fs-6 px-3 py-2">â¬† Most Important (Top of Board)</span>
</div>
<!-- ğŸ´ Main board -->
<div id="board" class="p-3 bg-light rounded shadow-sm">
  {% for ind in indicators %}
  <div class="card srf-card" data-id="{{ ind.id }}">
    <div class="card-body d-flex align-items-center justify-content-center text-center p-3">
      <h6 class="mb-0">{{ ind.name }}</h6>
    </div>
  </div>
  {% endfor %}
</div>
<div class="text-center mt-2">
  <span class="badge bg-primary-subtle text-primary fs-6 px-3 py-2">â¬‡ Less Important (Bottom of Board)</span>
</div>
<div class="d-flex justify-content-between mt-3">
  <span class="fw-bold text-danger ms-4">â¬‡ï¸ Most Important</span>
  <span class="fw-bold text-secondary me-4">Less Important â¬†ï¸</span>
</div>

<!-- ğŸ’¡ Right panel -->
<div class="col-lg-4 mt-4">
  <div class="card shadow-sm">
    <div class="card-body">
      <h5 class="card-title">ğŸ’¡ SRF Weight Summary</h5>
      <div id="summaryTable" class="small"></div>
      <button id="saveBtn" class="btn btn-primary w-100 mt-3">ğŸ’¾ Save SRF Weights</button>
    </div>
  </div>
</div>

<!-- ğŸ¨ Styles -->
<style>
/* === Diagonal board layout === */
#board {
  min-height: 600px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
  gap: 25px 30px;
  justify-items: center;
  align-items: start;
  padding: 60px 40px;
  border-radius: 16px;
  box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.05);
  position: relative;
  overflow-y: auto;
  max-height: 80vh;

  /* ğŸŒˆ Visual gradient showing importance */
  background: linear-gradient(
    to bottom,
    #fff3f3 0%,       /* red tint = most important */
    #f8fafc 50%,      /* neutral middle */
    #e9f5ff 100%      /* blue tint = less important */
  );
}
/* ğŸ”³ White card â€œgapâ€ â€” elegant separator between importance levels */
/* ğŸ”³ White card â€œgapâ€ â€” elegant slim spacer between importance groups */
.white-card {
  width: 180px;  /* narrower than normal cards */
  height: 70px;  /* shorter height for visual separation */
  border-radius: 10px;
  border: 2px dashed #94a3b8;
  background: repeating-linear-gradient(
    135deg,
    #ffffff,
    #ffffff 8px,
    #f1f5f9 8px,
    #f1f5f9 16px
  );
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  font-weight: 600;
  font-size: 0.9rem;
  color: #475569;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
  transition: all 0.2s ease;
  margin: 6px auto;
  position: relative;
  text-align: center;
}

.white-card::before {
  content: "â¬œ White Card";
  font-size: 0.8rem;
  color: #64748b;
  font-weight: 500;
  margin-bottom: 2px;
}

.white-card::after {
  content: "â†‘ Gap in importance";
  font-size: 0.7rem;
  color: #94a3b8;
  font-style: italic;
  margin-top: 2px;
}

.white-card:hover {
  transform: scale(1.05);
  border-color: #64748b;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
}

/* ğŸ”µ Highlight selected cards for merging */
.srf-card.selected {
  outline: 3px solid #2563eb;
  box-shadow: 0 0 10px rgba(37, 99, 235, 0.5);
  transform: scale(1.03);
  z-index: 10;
}
/* âš–ï¸ Equal Importance Group â€“ stacked visual style */
.group-card {
  position: relative;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
  gap: 8px;
  padding: 18px 12px 12px;
  border-radius: 14px;
  border: 2px solid #cbd5e1;
  background: #f8fafc;
  box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.05);
  transition: transform 0.2s ease;
}

.group-card::before {
  content: "âš–ï¸ Equal Importance Group";
  position: absolute;
  top: -12px;
  background: #f1f5f9;
  border: 1px solid #cbd5e1;
  border-radius: 6px;
  padding: 2px 8px;
  font-size: 0.8rem;
  color: #475569;
  font-weight: 600;
}

.group-card:hover {
  transform: scale(1.02);
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
}

.group-card .srf-card {
  transform: rotate(var(--r, 0deg)) translateY(0);
  margin: 2px;
  flex: 0 0 210px;
}

</style>

<!-- ğŸ“¦ SortableJS + html2canvas -->
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const board = document.getElementById("board");
  const addWhiteBtn = document.getElementById("addWhiteCard");
  const mergeBtn = document.getElementById("mergeCards");

  // âœ… Enable drag and drop
  Sortable.create(board, {
    animation: 150,
    ghostClass: 'dragging',
    handle: '.srf-card, .white-card, .group-card',
    onSort: updateCardOffsets
  });

  // âœ… Add white card
  addWhiteBtn.addEventListener("click", () => {
    const white = document.createElement("div");
    white.className = "white-card";
    white.textContent = "â¬œ White Card (Gap)";
    board.appendChild(white);
    updateCardOffsets();
  });

  // âœ… Select cards by clicking
 // âœ… Select multiple cards (for merge) with safe click detection
board.addEventListener("click", e => {
  // Ignore clicks on buttons or inputs (like ğŸ¨ or color picker)
  if (e.target.closest("button") || e.target.closest("input")) return;

  const card = e.target.closest(".srf-card");
  if (!card) return;

  // Toggle selection
  card.classList.toggle("selected");

  // Add a subtle visual pulse to confirm selection
  if (card.classList.contains("selected")) {
    card.style.outline = "3px solid #2563eb";
    card.style.boxShadow = "0 0 12px rgba(37,99,235,0.4)";
  } else {
    card.style.outline = "";
    card.style.boxShadow = "";
  }
});


  // âœ… Merge selected indicator cards
  mergeBtn.addEventListener("click", () => {
    const selected = [...board.querySelectorAll(".srf-card.selected")];
    if (selected.length < 2) {
      alert("Select at least 2 indicator cards to merge!");
      return;
    }

    const group = document.createElement("div");
    group.className = "group-card";
    group.innerHTML = `<div class="text-muted small mb-1">âš–ï¸ Equal Importance Group</div>`;

    const first = selected[0];
    board.insertBefore(group, first);
    selected.forEach(card => {
      card.classList.remove("selected");
      group.appendChild(card);
    });

    Sortable.create(group, {
      group: "shared",
      animation: 150,
      handle: '.srf-card',
      onSort: updateCardOffsets
    });
    updateCardOffsets();
  });

  // === Natural rotation for realism ===
  document.querySelectorAll('.srf-card').forEach(card => {
    const deg = (Math.random() * 3 - 1.5).toFixed(1);
    card.style.setProperty('--r', `${deg}deg`);
  });

  // === Diagonal offset update ===
  function updateCardOffsets() {
    document.querySelectorAll('#board > *').forEach((el, i) => {
      el.style.setProperty('--i', i);
    });
  }
  updateCardOffsets();

  const observer = new MutationObserver(updateCardOffsets);
  observer.observe(board, { childList: true, subtree: true });

  // === Color pickers and PNG download ===
  function addColorPickers() {
    board.querySelectorAll(".srf-card").forEach(card => {
      if (card.querySelector(".color-btn")) return;

      const colorInput = document.createElement("input");
      colorInput.type = "color";
      colorInput.className = "color-input";
      colorInput.value = card.dataset.color || "#ffffff";
      colorInput.style.display = "none";

      const emojiBtn = document.createElement("button");
      emojiBtn.className = "btn btn-sm btn-outline-secondary color-btn";
      emojiBtn.innerHTML = "ğŸ¨";
      emojiBtn.title = "Change card color";
      emojiBtn.style.position = "absolute";
      emojiBtn.style.top = "5px";
      emojiBtn.style.right = "5px";
      emojiBtn.style.padding = "2px 6px";
      emojiBtn.style.fontSize = "14px";

      emojiBtn.addEventListener("click", e => {
        e.stopPropagation();
        colorInput.click();
      });

      colorInput.addEventListener("input", e => {
        const color = e.target.value;
        card.style.backgroundColor = color;
        card.dataset.color = color;
        saveCardColors();
      });

      card.style.position = "relative";
      card.appendChild(emojiBtn);
      card.appendChild(colorInput);
    });
  }

  function saveCardColors() {
    const colors = {};
    board.querySelectorAll(".srf-card").forEach(card => {
      colors[card.dataset.id || card.innerText.trim()] = card.dataset.color || "#ffffff";
    });
    localStorage.setItem("cardColors", JSON.stringify(colors));
  }

  function loadCardColors() {
    const saved = JSON.parse(localStorage.getItem("cardColors") || "{}");
    board.querySelectorAll(".srf-card").forEach(card => {
      const key = card.dataset.id || card.innerText.trim();
      if (saved[key]) {
        card.style.backgroundColor = saved[key];
        card.dataset.color = saved[key];
      }
    });
  }

  const downloadBtn = document.createElement("button");
  downloadBtn.className = "btn btn-success mt-3";
  downloadBtn.innerHTML = "ğŸ“¸ Download Cards as PNG";
  document.querySelector(".col-lg-4").appendChild(downloadBtn);

  downloadBtn.addEventListener("click", async () => {
    downloadBtn.disabled = true;
    downloadBtn.innerText = "ğŸ“¸ Generating...";
    try {
      const canvas = await html2canvas(board, { scale: 2, backgroundColor: "#ffffff" });
      const link = document.createElement("a");
      link.download = `project_{{ project.id }}_srf_cards.png`;
      link.href = canvas.toDataURL("image/png");
      link.click();
    } finally {
      downloadBtn.disabled = false;
      downloadBtn.innerText = "ğŸ“¸ Download Cards as PNG";
    }
  });

  addColorPickers();
  loadCardColors();
});
</script>
<script>
document.addEventListener("DOMContentLoaded", () => {
  const saveBtn = document.getElementById("saveBtn");
  const summary = document.getElementById("summaryTable");
  const board = document.getElementById("board");

  // ğŸ” Gather order + groups from the visual board
  function getRankingData() {
    const items = [...board.children];
    const order = [];
    const groups = [];

    items.forEach(el => {
      if (el.classList.contains("white-card")) {
        order.push("gap");
      } else if (el.classList.contains("group-card")) {
        const groupIds = [...el.querySelectorAll(".srf-card")].map(c => c.dataset.id);
        order.push(...groupIds);
        groups.push(groupIds);
      } else if (el.classList.contains("srf-card")) {
        order.push(el.dataset.id);
        groups.push([el.dataset.id]);
      }
    });

    return { order, groups };
  }

 // ğŸ“Š Compute SRF-style weights (Top = Most Important)
// Handles "gap" (white cards) and equal-importance groups
function computeWeights(order, groups) {
  // Determine positions, ignoring white cards
  const cleanOrder = order.filter(item => item !== "gap");
  if (cleanOrder.length === 0) return {};

  let baseScore = cleanOrder.length; // Top card = highest score
  const scores = {};
  const visited = new Set();

  // We loop top â†’ bottom so white cards below reduce importance
  for (let i = 0; i < order.length; i++) {
    const item = order[i];

    if (item === "gap") {
      baseScore -= 1; // Gaps increase the step difference
      continue;
    }

    // Find the group that contains this indicator (if any)
    const group = groups.find(g => g.includes(item));
    if (group && !visited.has(group)) {
      visited.add(group);
      // Assign the same score to all indicators in this group
      group.forEach(id => {
        scores[id] = baseScore;
      });
      baseScore -= 1; // next group below gets lower importance
    } else if (!group) {
      scores[item] = baseScore;
      baseScore -= 1;
    }
  }

  // Normalize to 1.0 total
  const total = Object.values(scores).reduce((a, b) => a + b, 0) || 1;
  const weights = {};
  for (const [id, sc] of Object.entries(scores)) {
    weights[id] = (sc / total).toFixed(4);
  }

  return weights;
}

  // ğŸ§¾ Render results in the summary table
  function renderSummary(weights) {
    const rows = Object.entries(weights)
      .map(([id, w]) => {
        const card = document.querySelector(`.srf-card[data-id="${id}"]`);
        const name = card ? card.querySelector("h6").innerText : `Indicator ${id}`;
        return `<tr><td>${name}</td><td>${w}</td></tr>`;
      })
      .join("");

    summary.innerHTML = `
      <h6 class="mb-2">ğŸ“Š Computed SRF Weights</h6>
      <table class="table table-sm table-bordered">
        <thead class="table-light">
          <tr><th>Indicator</th><th>Weight</th></tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
      <p class="text-muted small mt-2">
        Total = 1.0000 (normalized). Higher weight â†’ higher importance.
      </p>
    `;
  }

  // ğŸ’¾ Save & compute weights
  saveBtn.addEventListener("click", () => {
    const { order, groups } = getRankingData();

    if (!order.length) {
      alert("âš ï¸ No indicators detected! Make sure cards are on the board.");
      return;
    }

    const weights = computeWeights(order, groups);
    renderSummary(weights);

    fetch("{% url 'indicator_ranking_view' project.id %}", {
      method: "POST",
      headers: {
        "X-CSRFToken": "{{ csrf_token }}",
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ order, groups }),
    })
      .then(res => res.json())
      .then(data => {
        if (data.status === "success") {
          alert("âœ… SRF weights calculated and saved successfully!");
        } else {
          alert("âš ï¸ Error saving weights: " + (data.message || "Unknown issue"));
          console.error(data);
        }
      })
      .catch(err => {
        console.error("Network error:", err);
        alert("âŒ Network error. Please try again.");
      });
  });
});
</script>

{% endblock %}
